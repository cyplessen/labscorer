% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_sum_scores.R
\name{create_sum_scores}
\alias{create_sum_scores}
\title{Score all detected scales and build a diagnostic database}
\usage{
create_sum_scores(df, specs, na_rm = FALSE, verbose = TRUE)
}
\arguments{
\item{df}{A data frame with item-level columns.}

\item{specs}{A named list of scale specifications. Each element should be a
list with at least \code{scale} and \code{item_indices}, plus optional fields
accepted by \code{\link[=calculate_sum_scores]{calculate_sum_scores()}}.}

\item{na_rm}{Logical; passed through to \code{\link[=calculate_sum_scores]{calculate_sum_scores()}}. Default
\code{FALSE}.}

\item{verbose}{Logical; print detected scales to the console? Default \code{TRUE}.}
}
\value{
A list with two elements:
\describe{
\item{\code{df}}{The input data frame with all score columns appended.}
\item{\code{database}}{A tibble with one row per scale × timepoint containing
spec metadata and a nested \code{created_score_stats} diagnostics table.}
}
}
\description{
Iterates over a named list of scale specifications, detects which scales have
matching columns in \code{df}, calls \code{\link[=calculate_sum_scores]{calculate_sum_scores()}} for each, and
returns the scored data frame together with a diagnostic \code{scale_database}.
}
\details{
The database contains one row per scale × timepoint, with a nested
\code{created_score_stats} tibble that records observed vs. theoretical score
ranges and an \code{out_of_range} flag for automatic quality control.
}
\section{Typical workflow}{


\if{html}{\out{<div class="sourceCode r">}}\preformatted{options(labscorer.timepoint_prefix = "t")

result <- create_sum_scores(df_raw, scale_specs_all)
df_scored      <- result$df
scale_database <- result$database

# Check for problems
scale_database |>
  tidyr::unnest(created_score_stats) |>
  dplyr::filter(out_of_range)
}\if{html}{\out{</div>}}
}

\examples{
options(labscorer.timepoint_prefix = "t")
specs <- list(
  phq = list(scale = "phq", item_indices = 1:9, min_score = 0, max_score = 3)
)
# result <- create_sum_scores(df_raw, specs)
# result$df
# result$database
}
